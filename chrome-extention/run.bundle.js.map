{"version":3,"file":"run.bundle.js","mappings":";;;;;;;;;;;;;;AAWA;;AAEA;AACA;AAQA;AAPA;AACA;AACA;AACA;AAsBA;AAEA;AAGA;AACA;AAEA;AAzBA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAWA;;;;;;;;;;;;;;;;ACjDA;AAMA;AAEA;;AAEA;AACA;AAQA;AAPA;AAUA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvDA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;ACdA;;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;AClBA;AACA;AAaA;AAEA;;AAEA;AACA;AAAA;AAmIA;AACA;AAQA;AAgBA;AACA;AAmBA;AA/KA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnMA;AAQA;;AAEA;AACA;AAAA;AACA;AAsBA;AArBA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClCA;AAQA;;AAEA;AACA;AAOA;AANA;AACA;AACA;AAqCA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAlCA;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://gmeet-cc-decoration/./src/config.ts","webpack://gmeet-cc-decoration/./src/core/ccOveserver.ts","webpack://gmeet-cc-decoration/./src/core/dom.ts","webpack://gmeet-cc-decoration/./src/core/selector.ts","webpack://gmeet-cc-decoration/./src/elements/UsersAreaElement.ts","webpack://gmeet-cc-decoration/./src/elements/ccAreaElement.ts","webpack://gmeet-cc-decoration/./src/elements/controlButtonElement.ts","webpack://gmeet-cc-decoration/./src/main.ts","webpack://gmeet-cc-decoration/webpack/bootstrap","webpack://gmeet-cc-decoration/webpack/runtime/define property getters","webpack://gmeet-cc-decoration/webpack/runtime/hasOwnProperty shorthand","webpack://gmeet-cc-decoration/webpack/runtime/make namespace object","webpack://gmeet-cc-decoration/./src/run.ts"],"sourcesContent":["export interface ConfigInterface {\n  loadConfig(): Promise<void>\n  getConfig(): ConfigObjectInterface\n  setConfig(config: ConfigObjectInterface): void\n}\n\nexport interface ConfigObjectInterface {\n  opacityRate: number\n  isDisplayOriginalCc: number\n}\n\n/**\n * ポップアップ内で入力した設定情報\n */\nexport class Config implements ConfigInterface {\n  private config: ConfigObjectInterface = {\n    opacityRate: 0.5,\n    isDisplayOriginalCc: 1,\n  }\n\n  private callbackFuncChangeConfig: (config: ConfigObjectInterface) => void\n\n  constructor(callbackFunc: (config: ConfigObjectInterface) => void) {\n    this.callbackFuncChangeConfig = callbackFunc\n  }\n\n  getConfig(): ConfigObjectInterface {\n    return this.config\n  }\n\n  setConfig(config: ConfigObjectInterface): void {\n    this.config = config\n    this.callbackFuncChangeConfig(this.config)\n  }\n\n  async loadConfig(): Promise<void> {\n    const config = await this.getStorage()\n    this.setConfig(config)\n  }\n\n  private getStorage = (): Promise<ConfigObjectInterface> =>\n    new Promise((resolve) => {\n      chrome.storage.local.get(\n        [\"opacityRate\", \"isDisplayOriginalCc\"],\n        (data) => {\n          resolve(data as ConfigObjectInterface)\n        }\n      )\n    })\n}\n","import { CcAreaElement } from \"@/elements/ccAreaElement\"\nexport interface ccOveserverInterface {\n  run: () => void\n  stop: () => void\n}\n\nconst config = { childList: true, subtree: true }\n\n/**\n * 字幕の変更監視クラス\n */\nexport class CcOveserver implements ccOveserverInterface {\n  private observer: MutationObserver | null = null\n  private callbackFuncObserver: (\n    name: string,\n    imagePath: string,\n    speach: string\n  ) => void\n\n  constructor(\n    callbackFunc: (name: string, imagePath: string, speach: string) => void\n  ) {\n    this.callbackFuncObserver = callbackFunc\n  }\n  run() {\n    const mutationCallback: MutationCallback = (\n      mutations: MutationRecord[],\n      observer: MutationObserver\n    ) => {\n      for (const mutation of mutations) {\n        if (mutation.type === \"childList\") {\n          if (mutation.target.nodeName === \"SPAN\") {\n            const speechAreaNode = mutation.target\n            const userAreaNode =\n              speechAreaNode.parentNode?.parentNode?.parentNode\n            if (!userAreaNode) return\n            const userAreaNodeList = Array.from(userAreaNode.children)\n            if (userAreaNodeList.length !== 3) return\n            this.callbackFuncObserver(\n              userAreaNodeList[1].textContent ?? \"\",\n              (userAreaNodeList[0] as HTMLImageElement).src,\n              userAreaNodeList[2].textContent ?? \"\"\n            )\n          }\n        }\n      }\n    }\n\n    this.observer = new MutationObserver(mutationCallback)\n    const oveserverNode = new CcAreaElement().getCcElement()\n    this.observer.observe(<Node>oveserverNode, config)\n  }\n  stop() {\n    this.observer?.disconnect()\n  }\n}\n","/**\n * Elementの削除を行います。\n * @param el\n * @param speed\n */\nconst removeElement = (el: HTMLElement, speed: number) => {\n  var seconds = speed / 1000\n  el.style.transition = \"opacity \" + seconds + \"s ease\"\n  el.style.opacity = \"0\"\n  setTimeout(function () {\n    el.parentNode?.removeChild(el)\n  }, speed)\n}\n\nexport { removeElement }\n","/**\n * GoogleMeetのElementのセレクター\n */\nconst controlCcButton =\n  \"#ow3 > div.T4LgNb > div > div:nth-child(13) > div.crqnQb > div.UnvNgf.Sdwpn.P9KVBf.IYIJAc.BIBiNe > div.Tmb7Fd > div > div.juFBl\"\nconst ccMainArea = \".a4cQT\"\nconst ccArea =\n  \"#ow3 > div.T4LgNb > div > div:nth-child(13) > div.crqnQb > div.a4cQT > div:nth-child(1) > div:nth-child(1)\"\nconst usersArea =\n  \"#ow3 > div.T4LgNb > div > div:nth-child(13) > div.crqnQb > div:nth-child(2) > div.axUSnc.P9KVBf\"\n\nconst selector = {\n  controlCcButton: controlCcButton,\n  ccMainArea: ccMainArea,\n  ccArea: ccArea,\n  usersArea: usersArea,\n}\n\nexport { selector }\n","import { selector } from \"@/core/selector\"\nimport { removeElement } from \"@/core/dom\"\nexport interface usersAreaElementInterface {\n  getElement(): HTMLElement | null\n  findUserAreaElement: (name: string) => Element | undefined\n  findUserVideoElement: (name: string) => HTMLVideoElement | undefined\n  findUserCcElement: (name: string) => HTMLDivElement | undefined\n  appendUserCcElement: (name: string, speach: string) => void\n  updateUserCcElement: (name: string, speach: string) => void\n  deleteUserCcElement: (name: string) => void\n  runInterval: () => void\n  stopInterval: () => void\n}\n\nconst userCcClassName = \"user-cc-class-name\"\n\n/**\n * ユーザーエリアのElementに関するクラス\n */\nexport class UsersAreaElement implements usersAreaElementInterface {\n  getElement(): HTMLElement | null {\n    return document.querySelector<HTMLElement>(selector.usersArea)\n  }\n\n  // ユーザーエリアの要素を取得\n  findUserAreaElement(name: string): Element | undefined {\n    const usersAreaElement = this.getElement()\n    if (!usersAreaElement) return undefined\n\n    const userAreaList = Array.from(usersAreaElement.children)\n    return userAreaList.find((element) => {\n      // 画面共有ようのエリアはinnerTextが取得できないのでその対応\n      const userNameArea = element.querySelector(\"[data-self-name]\")\n      if (!userNameArea) return false\n      if (userNameArea.textContent?.startsWith(name)) {\n        return true\n      }\n      return false\n    })\n  }\n\n  // ユーザーのvideo要素を取得\n  findUserVideoElement(name: string): HTMLVideoElement | undefined {\n    const userAreaElement = this.findUserAreaElement(name)\n    if (!userAreaElement) return undefined\n\n    // 非表示のVideoタグが紛れる事があるのでその対応。\n    const videoAreaElements = userAreaElement.querySelectorAll(\"video\")\n    let userVideoElement: HTMLVideoElement | null = null\n    if (videoAreaElements.length >= 2) {\n      videoAreaElements.forEach((element) => {\n        if (element.style.display == \"none\") return\n        userVideoElement = element\n      })\n    } else {\n      userVideoElement = videoAreaElements[0]\n    }\n    return userVideoElement !== null ? userVideoElement : undefined\n  }\n\n  // ユーザー字幕の取得\n  findUserCcElement(name: string): HTMLDivElement | undefined {\n    const userAreaElement = this.findUserAreaElement(name)\n    if (!userAreaElement) return undefined\n\n    const userCcElement = userAreaElement.querySelector(\".\" + userCcClassName)\n    return userCcElement !== null ? <HTMLDivElement>userCcElement : undefined\n  }\n\n  // 字幕 追加\n  appendUserCcElement(name: string, speach: string): void {\n    const userAreaElement = this.findUserAreaElement(name)\n    if (!userAreaElement) return\n\n    const userVideoElement = this.findUserVideoElement(name)\n    if (!userVideoElement) return\n\n    const userCcElement = document.createElement(\"div\")\n    userCcElement.style.color = \"white\"\n    userCcElement.style.position = \"absolute\"\n    userCcElement.style.bottom = \"0\"\n    userCcElement.style.backgroundColor = \"rgba(0,0,0,0.25)\"\n    userCcElement.style.margin = \"0\"\n    userCcElement.style.zIndex = \"1000000\"\n    userCcElement.textContent = speach\n    userCcElement.className = userCcClassName\n    userCcElement.style.opacity = this.userCcOpacityRate.toString()\n    userCcElement.style.fontWeight = \"700\"\n    userCcElement.style.textAlign = \"center\"\n    userCcElement.style.pointerEvents = \"none\"\n    const fontSize = Math.floor(userVideoElement.clientWidth / 35)\n    fontSize < 18\n      ? (userCcElement.style.fontSize = \"15px\")\n      : (userCcElement.style.fontSize = `${fontSize}px`)\n    fontSize < 27\n      ? (userCcElement.style.webkitTextStroke = \"1px #000\")\n      : (userCcElement.style.webkitTextStroke = \"2px #000\")\n    userVideoElement.parentElement?.after(userCcElement)\n\n    if (fontSize >= 18) {\n      userCcElement.style.height = `${userVideoElement.clientHeight / 4.3}px`\n    }\n    userCcElement.style.width = \"100%\"\n    // ログに追加\n    const userCcEmenet = this.findUserCcElement(name)\n    if (!userCcEmenet) return\n    this.appendDisplayUserCc(name, userCcEmenet)\n  }\n\n  // 字幕 更新\n  updateUserCcElement(name: string, speach: string): void {\n    const userAreraElement = this.findUserAreaElement(name)\n    if (!userAreraElement) return\n\n    const userVideoElement = this.findUserVideoElement(name)\n    if (!userVideoElement) return\n\n    const userCcElement = this.findUserCcElement(name)\n    if (!userCcElement) return\n\n    userCcElement.textContent = speach\n    const fontSize = Math.floor(userVideoElement.clientWidth / 35)\n    fontSize < 18\n      ? (userCcElement.style.fontSize = \"15px\")\n      : (userCcElement.style.fontSize = `${fontSize}px`)\n    fontSize < 27\n      ? (userCcElement.style.webkitTextStroke = \"1px #000\")\n      : (userCcElement.style.webkitTextStroke = \"2px #000\")\n\n    if (fontSize >= 18) {\n      userCcElement.style.height = `${userVideoElement.clientHeight / 4.3}px`\n    }\n    // ログに追加\n    this.appendDisplayUserCc(name, userCcElement)\n  }\n\n  // 字幕 削除\n  deleteUserCcElement(name: string): void {\n    const displaySpeach = this.displayUserCcList.find((x) => x.name === name)\n    if (!displaySpeach) return\n    removeElement(displaySpeach.element, 2000)\n  }\n\n  // 全字幕 削除\n  deleteUserCcElements(): void {\n    this.displayUserCcList.forEach((x) => {\n      removeElement(x.element, 2000)\n    })\n  }\n\n  // 字幕の透明度を変える\n  private userCcOpacityRate = 0.5\n  setUserCcOpacityRate(opacityRate: number) {\n    this.userCcOpacityRate = opacityRate\n    this.displayUserCcList.forEach((x) => {\n      x.element.style.opacity = this.userCcOpacityRate.toString()\n    })\n  }\n\n  private displayUserCcList: {\n    name: string\n    time: number\n    element: HTMLElement\n  }[] = []\n  private appendDisplayUserCc(name: string, element: HTMLElement) {\n    this.displayUserCcList = this.displayUserCcList.filter(\n      (displayUserSpeash) => displayUserSpeash.name !== name\n    )\n    this.displayUserCcList.push({\n      name: name,\n      time: new Date().getTime(),\n      element: element,\n    })\n  }\n\n  private readonly cclimitSecond = 7\n  private intervalId: number = 0\n  runInterval() {\n    // 一定時間表示した字幕は消す\n    this.intervalId = window.setInterval(() => {\n      const oldDisplayUserCcList = this.displayUserCcList.filter(\n        (x) => (new Date().getTime() - x.time) / 1000 > this.cclimitSecond\n      )\n      oldDisplayUserCcList.forEach((x) => {\n        removeElement(x.element, 2000)\n      })\n      this.displayUserCcList = this.displayUserCcList.filter(\n        (x) => (new Date().getTime() - x.time) / 1000 < this.cclimitSecond\n      )\n    }, 3000)\n  }\n\n  stopInterval() {\n    clearInterval(this.intervalId)\n  }\n}\n","import { selector } from \"@/core/selector\"\n\nexport interface ccAreaElementInterface {\n  hideElement(): void\n  showElement(): void\n  getElement(): HTMLElement | null\n}\n\n/**\n * 字幕エリアのElementに関するクラス\n */\nexport class CcAreaElement implements ccAreaElementInterface {\n  opacate = false\n  hideElement(): void {\n    const element = this.getElement()\n    if (element === null) return\n    element.style.opacity = \"0\"\n    this.opacate = true\n  }\n\n  showElement(): void {\n    const element = this.getElement()\n    if (element === null) return\n    element.style.opacity = \"1\"\n    this.opacate = false\n  }\n\n  getElement(): HTMLElement | null {\n    return document.querySelector<HTMLElement>(selector.ccMainArea)\n  }\n\n  getCcElement(): HTMLElement | null {\n    return document.querySelector<HTMLElement>(selector.ccArea)\n  }\n}\n","import { selector } from \"@/core/selector\"\n\nexport interface ControlButtonElementInterface {\n  createElement(): void\n  deleteElement(): void\n  getElement(): HTMLElement | null\n}\n\n/**\n * システムのコントロールボタンに関するクラス\n */\nexport class ControlButtonElement implements ControlButtonElementInterface {\n  private drawed = false\n  private mouseOver = false\n  private clicked = false\n  static ELEMENT_ID = \"controlButton\"\n  private clickCallback: (clicked: boolean) => void\n\n  constructor(callback: (clicked: boolean) => void) {\n    this.clickCallback = callback\n  }\n\n  createElement() {\n    const element = document.createElement(\"div\")\n    element.id = ControlButtonElement.ELEMENT_ID\n    element.addEventListener(\"mouseover\", this.callbackFuncMouseOver)\n    element.addEventListener(\"mouseleave\", this.callbackFuncMouseLeave)\n    element.addEventListener(\"click\", this.callbackFuncClick)\n\n    const ccButtonElement = document.querySelector(selector.controlCcButton)\n    if (ccButtonElement !== null && ccButtonElement.parentNode != null) {\n      ccButtonElement.parentNode.insertBefore(\n        element,\n        ccButtonElement.nextElementSibling\n      )\n      this.changeStyle()\n      this.drawed = true\n    }\n  }\n\n  deleteElement() {\n    document.getElementById(ControlButtonElement.ELEMENT_ID)?.remove()\n    this.drawed = false\n    this.mouseOver = false\n    this.clicked = false\n  }\n\n  getElement(): HTMLElement | null {\n    return document.getElementById(ControlButtonElement.ELEMENT_ID)\n  }\n\n  // このへんのhandle処理から\n  private callbackFuncMouseOver: (e: any) => void = () => {\n    this.mouseOver = true\n    this.changeStyle()\n  }\n\n  private callbackFuncMouseLeave: (e: any) => void = () => {\n    this.mouseOver = false\n    this.changeStyle()\n  }\n\n  private callbackFuncClick: (e: any) => void = () => {\n    this.clicked = !this.clicked\n    this.changeStyle()\n    this.clickCallback(this.clicked)\n  }\n\n  private changeStyle: () => void = () => {\n    const element = this.getElement()\n    if (element === null) return\n\n    element.style.width = \"40px\"\n    element.style.height = \"40px\"\n    element.style.backgroundColor = \"rgb(60, 64, 67)\"\n    element.style.borderRadius = \"20px\"\n    element.style.paddingTop = \"12px\"\n    element.style.paddingBottom = \"12px\"\n    element.style.display = \"inline-block\"\n    element.style.boxSizing = \"border-box\"\n    element.style.filter = \"brightness(1)\"\n    element.innerText = \"ON\"\n    element.style.color = \"#FFF\"\n\n    if (this.mouseOver) {\n      element.style.filter = \"brightness(1.15)\"\n    }\n    if (this.clicked) {\n      element.style.color = \"#000\"\n      element.innerText = \"OFF\"\n      element.style.backgroundColor = \"rgb(138,180,248)\"\n    }\n  }\n}\n","import { Config, ConfigObjectInterface } from \"@/config\"\nimport { UsersAreaElement } from \"@/elements/UsersAreaElement\"\nimport { ControlButtonElement } from \"@/elements/controlButtonElement\"\nimport { CcAreaElement } from \"@/elements/ccAreaElement\"\nimport { CcOveserver } from \"@/core/ccOveserver\"\n\nexport const main = () => {\n  console.log(\"start: application\")\n  /**\n   * コントロールボタン押下後のコールバック関数\n   * @param clicked\n   */\n  const callbackFuncClick = (clicked: boolean) => {\n    console.log(\"click: controlButton\")\n    if (clicked) {\n      ccOveserver.run()\n      console.log(\"start: observer\")\n      usersAreaElement.runInterval()\n      console.log(\"run: interval\")\n    } else {\n      ccOveserver.stop()\n      console.log(\"stop: observer\")\n      usersAreaElement.stopInterval()\n      console.log(\"stop: interval\")\n      usersAreaElement.deleteUserCcElements()\n      console.log(\"delete: cc elements\")\n    }\n  }\n\n  /**\n   * 字幕変更検知後のコールバック関数\n   * @param name\n   * @param imagePath\n   * @param speach\n   */\n  const callbackFuncObserver = (\n    name: string,\n    imagePath: string,\n    speach: string\n  ) => {\n    console.log(\"mutate: cc\")\n    console.log(`name: ${name}`)\n    console.log(`imagePath: ${imagePath}`)\n    console.log(`speach: ${speach}`)\n\n    if (!usersAreaElement.findUserCcElement(name)) {\n      usersAreaElement.appendUserCcElement(name, speach)\n    } else {\n      usersAreaElement.updateUserCcElement(name, speach)\n    }\n  }\n\n  const usersAreaElement = new UsersAreaElement()\n  const ccAreaElement = new CcAreaElement()\n  const controlButtonElement = new ControlButtonElement(callbackFuncClick)\n  controlButtonElement.createElement()\n  const ccOveserver = new CcOveserver(callbackFuncObserver)\n\n  /**\n   * 設定ファイル変更時のコールバック関数\n   * @param config\n   */\n  const callbackFuncChangeConfig = (config: ConfigObjectInterface) => {\n    console.log(\"callback simasuta!\")\n    // 字幕の透明度\n    usersAreaElement.setUserCcOpacityRate(config.opacityRate)\n\n    // 字幕の表示非表示制御\n    if (config.isDisplayOriginalCc == 1) {\n      ccAreaElement.showElement()\n    } else {\n      ccAreaElement.hideElement()\n    }\n  }\n  const config = new Config(callbackFuncChangeConfig)\n  config.loadConfig()\n\n  // ポップアップ側の変更検知\n  chrome.runtime.onMessage.addListener(function (\n    message: string,\n    sender,\n    sendResponse\n  ) {\n    console.log(\"receive: popup → content_scripts\")\n    const data = <ConfigObjectInterface>JSON.parse(message)\n    config.setConfig(data)\n  })\n}\n\n// 動作確認用の入口\ndocument.addEventListener(\"runScript\", (e) => {\n  main()\n})\n\n// // script呼び出し用イベント\n// const event = new Event(\"runScript\", { bubbles: true })\n// document.dispatchEvent(event)\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { selector } from \"@/core/selector\"\nimport { main } from \"@/main\"\nwindow.addEventListener(\"load\", run, false)\n\nfunction run() {\n  const jsInitCheckTimer = setInterval(jsLoaded, 1000)\n  function jsLoaded() {\n    if (document.querySelector(selector.ccMainArea) != null) {\n      clearInterval(jsInitCheckTimer)\n      main()\n    }\n  }\n}\n"],"names":[],"sourceRoot":""}